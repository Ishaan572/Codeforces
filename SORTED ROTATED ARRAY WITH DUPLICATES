public static int findPivot(int[] nums) {
    int l = 0, r = nums.length - 1;

    while (l < r) {
        int mid = l + (r - l) / 2;

        // 1. Immediate Discovery: Check if mid is the "break" point
        if (mid < r && nums[mid] > nums[mid + 1]) return mid + 1;
        if (mid > l && nums[mid] < nums[mid - 1]) return mid;

        // 2. The "Blind Zone" Fix: All three are equal
        if (nums[l] == nums[mid] && nums[mid] == nums[r]) {
            // Before shrinking, check if l or r were the pivot
            if (nums[l] > nums[l + 1]) return l + 1;
            l++;
            if (nums[r] < nums[r - 1]) return r;
            r--;
        }
        // 3. Standard Binary Search Logic
        else if (nums[mid] >= nums[l] && nums[mid] > nums[r]) {
            l = mid + 1; // Pivot is in the right half
        } else {
            r = mid - 1; // Pivot is in the left half
        }
    }
    return l;
}
